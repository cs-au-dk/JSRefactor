
We have four representations of a JavaScript program:

1. Plain source code
2. Abstract syntax tree
3. Controlflow graph
4. Dataflow graph

Each representation is constructed using an instance in the previous representation as input:

Plain source code
	|
	| dk.brics.jsparser.SemicolonInsertingLexer
	| dk.brics.jsparser.parser.Parser (generated by SableCC)
	|
	V
Abstract syntax tree (jsparser project)
	|
	| dk.brics.jscontrolfow.ast2cfg.Ast2Cfg
	|
	V
Controlflow graph (jscontrolflow project)
	|
	| dk.brics.jspointers.cfg2dataflow.DataflowCreator
	|
	V
Dataflow graph (jspointers project)
	|
	X (fixpoint analysis runs here)


The relationships between these representations are stored so results can be interpreted in the context of
the original source code.

ABSTRACT SYNTAX TREE

The source code is converted to a string of tokens. Concatenating the text in these tokens will result in the original source code.
The tokens are connected in a doubly-linked list called the "token chain". The token chain can be accessed using:
	Token.getNext()
	Token.getPrevious()
A token knows its own line number and character index on that line:
	Token.getLine()
	Token.getPos()
A token also knows if it was inserted by automatic semicolon insertion.
	Token.isAutomaticallyInserted()

Some tokens are leaves in the AST, and some of them (such as whitespace) are not in the AST. The token chain contains ALL tokens, however.

A definition of the AST can be found at the bottom of the file "jsparser/grammar/javascript.sablecc".

CONTROLFLOW GRAPH

The controlflow graph is composed of Functions, Blocks, and Statements. A Function's body is a graph of blocks, with each block containing a
sequence of statements. The whole program is represented by a tree of Functions, arranged according to their lexical nesting in the source code.
The root of that tree is a Function object representing the top-level scope.

A Statement is a non-recursive structure, in contrast to AST expressions.
We introduce temporary variables to decompose nested expression into several statements. Temporary variables don't exist in JavaScript directly.
Variables in JavaScript (those that actually have names) are called "program variables" from this point on.

The controlflow graph also contains Scope objects. A Scope is a lexical construct that can define variables in its body. There are three types of scopes:
	1. The body of a function (includes the top-level scope)
	2. The body of a with statement
	3. The body of a catch clause
Statements that interact with scopes (such as ReadVariable,WriteVariable) have a reference to the Scope object it interacts with.

The semantics of each statement type should be described in the Javadoc for its class. We define some properties for a "wellformed" controlflow graph
in the Javadoc for: dk.brics.jscontrolflow.checks.CheckWellformed.

The relationship between AST and CFG is stored in an instance of IAstBinding (currently implemented by AstBinding).

DATAFLOW GRAPH

...

